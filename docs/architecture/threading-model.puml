@startuml
actor "Client app" as App
participant "Client Thread" as Client
note over Client
    Thread of an application,
    used to transfer commands
    to Command thread.
end note
participant "Command Thread" as Command
/ note over Command
    Main thread of the library.
    It executes biggest part of logic
    that is implemented in Libindy
end note
participant "Expensive Thread" as Expensive
/ note over Expensive
    Thread that is occasionally
    used for execution of
    some heavy operations like
    credential definition creation
    or key derivation
end note
participant "Pool Thread" as Pool
/ note over Pool
    Thread used for communication
    with nodes in pool
end note
actor "Pool with nodes" as Nodes #blue

==Common command cycle==
App -> Client: indy_create_and_store_my_did
activate Client
Client -> Command: CreateAndStoreMyDid
activate Command
Command -> Command: do_logic
Client --> App: error code
note over App
    App waits for result
    asynchronously if there
    was no error before
end note
deactivate Client
Command -> Command: execute callback
Command --> App: result
deactivate Command

==Expensive commands (key derivation, credential definition creation)==
App -> Client: indy_issuer_create_and_store_credential_def
activate Client
Client -> Command: CreateAndStoreCredentialDefinition
activate Command
Client --> App: error code
deactivate Client
note over App
    App waits for result
    asynchronously if there
    was no error before
end note
Command -> Command: CreateCredentialDefinition
Command -> Expensive: new_credential_definition
deactivate Command
note over Command
    Command thread can execute
    other commands during
    the work of expensive thread
end note
activate Expensive
Expensive -> Command: CreateAndStoreCredentialDefinitionContinue
deactivate Expensive
activate Command
Command -> Command: execute callback
Command --> App: result
deactivate Command

==Pool communication commands==
App -> Client: indy_open_pool
activate Client
Client -> Command: Open
activate Command
Client --> App: error code
deactivate Client
Command -> Pool: Pool::new
activate Pool
Pool -> Nodes: sync network
Nodes --> Pool: fresh network info
Command --> App: pool_handle
deactivate Command

note over App
    From now on pool works
    and requests can be sent
end note

App -> Client: indy_submit_request
activate Client
Client -> Command: SubmitRequest
activate Command
Client --> App: error code
deactivate Client

note over App
    App waits for result
    asynchronously if there
    was no error before
end note
Command -> Command: send_tx
Command -> Pool: _send_message
note over Command
    Command thread can execute
    other commands during
    the work of pool thread
end note
deactivate Command
Pool -> Nodes: send(json)
Nodes -> Pool: responses
Pool --> Command: aggregated response
activate Command
Command --> App: result
deactivate Command

note over App
    When the work is over,
    you should close the pool
    and it will kill the thread
end note

App -> Client: indy_close_pool
activate Client
Client -> Command: Close
activate Command
Client -> App: error code
deactivate Client
Command -> Pool: Pool::close
deactivate Pool
Command --> App: error code
deactivate Command
@enduml